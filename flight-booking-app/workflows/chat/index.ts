import {
  convertToModelMessages,
  type UIMessageChunk,
  type UIMessage,
  type ModelMessage,
} from 'ai';
import { DurableAgent } from '@workflow/ai/agent';
import { FLIGHT_ASSISTANT_PROMPT, flightBookingTools } from './steps/tools';
import { getWritable, getWorkflowMetadata } from 'workflow';
import { chatMessageHook } from './hooks/chat-message';
import {
  writeRequestReceived,
  writeUserMessageMarker,
  writeStreamClose,
  writeTurnEnd,
} from './steps/writer';

/**
 * Multi-turn chat workflow.
 *
 * A single workflow handles the entire conversation session across multiple turns.
 * The workflow owns the conversation state, and follow-up messages are injected via hooks.
 *
 * @param initialMessages - The initial messages to start the conversation
 * @param requestReceivedAt - Timestamp when the API received the request (t=0)
 */
export async function chat(initialMessages: UIMessage[], requestReceivedAt: number) {
  'use workflow';

  const { workflowRunId: runId, workflowStartedAt } = getWorkflowMetadata();
  const writable = getWritable<UIMessageChunk>();
  const workflowStartTime = workflowStartedAt.getTime();

  // FIRST: Emit request-received (t=0)
  await writeRequestReceived(writable, requestReceivedAt);

  console.log(
    `Starting chat workflow ${runId} with ${initialMessages.length} messages`
  );

  // Convert UI messages to model messages for the agent
  const messages: ModelMessage[] = await convertToModelMessages(initialMessages);

  // Write markers for initial user messages (for replay purposes)
  let isFirstUserMessage = true;
  for (const msg of initialMessages) {
    if (msg.role === 'user') {
      const textContent = msg.parts
        .filter((p) => p.type === 'text')
        .map((p) => (p as { type: 'text'; text: string }).text)
        .join('');
      if (textContent) {
        await writeUserMessageMarker(writable, textContent, msg.id, {
          turnNumber: 1, // First turn is turn 1
          turnStartedAt: workflowStartTime,
          workflowRunId: runId,
          workflowStartedAt: workflowStartTime,
          isFirstTurn: isFirstUserMessage,
        });
        isFirstUserMessage = false;
      }
    }
  }

  const agent = new DurableAgent({
    model: 'bedrock/claude-haiku-4-5-20251001-v1',
    system: FLIGHT_ASSISTANT_PROMPT,
    tools: flightBookingTools,
  });

  // Create a hook that uses the run ID as the token for resumption
  // This allows clients to send follow-up messages using just the run ID
  const hook = chatMessageHook.create({ token: runId });

  let turnNumber = 0;
  let totalStepCount = 0; // Accumulated step count (updated via return values)

  // Main conversation loop - process turns until session ends
  while (true) {
    turnNumber++;
    const turnStartTime = Date.now();
    console.log(`Turn ${turnNumber} starting`);

    // Process the current messages with the agent
    const result = await agent.stream({
      messages,
      writable,
      preventClose: true, // Keep stream open for follow-up messages
      sendStart: turnNumber === 1, // Only send start on first turn
      sendFinish: false, // We'll send finish when session ends
    });

    // Compute step data with unique step numbers across the workflow
    // Note: We use the accumulated totalStepCount as the base offset
    const stepsForTurn = result.steps.map((step, index) => ({
      stepNumber: totalStepCount + index + 1,
      toolCalls: step.toolCalls?.map((tc) => tc.toolName) || [],
      finishReason: step.finishReason || 'unknown',
      tokenUsage: step.usage,
    }));

    // Write turn-end and step data after agent completes
    // The step returns the new total step count
    totalStepCount = await writeTurnEnd(
      writable,
      turnNumber,
      Date.now() - turnStartTime,
      stepsForTurn,
      totalStepCount
    );

    // Update messages with the agent's response
    // result.messages contains the new messages generated by the agent (assistant response)
    messages.push(...result.messages);

    // Wait for the next user message via the hook
    // The client will call the follow-up API to inject messages
    const { message: followUp } = await hook;

    // Check for session end signal
    if (followUp === '/done') {
      console.log(`Ending workflow session`);
      console.log(`Finished workflow session with ${messages.length} messages`);
      break;
    }

    // The follow-up will be processed in the NEXT turn
    const nextTurnNumber = turnNumber + 1;
    console.log(`Turn ${nextTurnNumber}: follow-up received`);

    // Generate a unique ID for the follow-up message
    const followUpId = `user-${runId}-${nextTurnNumber}`;

    const followUpTurnStartTime = Date.now();

    // Write a marker for the follow-up message with observability context
    await writeUserMessageMarker(writable, followUp, followUpId, {
      turnNumber: nextTurnNumber,
      turnStartedAt: followUpTurnStartTime,
      workflowRunId: runId,
      workflowStartedAt: workflowStartTime,
      isFirstTurn: false,
    });

    // Add the follow-up message to the conversation
    messages.push({ role: 'user', content: followUp });
  }

  // Close the stream with workflow-end observability data
  await writeStreamClose(writable, {
    workflowRunId: runId,
    totalDurationMs: Date.now() - workflowStartTime,
    turnCount: turnNumber,
  });

  return { messages };
}
